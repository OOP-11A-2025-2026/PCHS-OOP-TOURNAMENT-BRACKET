# PCHS-OOP-TOURNAMENT-BRACKET
★ Ако виждате това господине, не ни давайте коледен проект. ★
# Tournament Project

Това е Java проект за управление на турнири с елиминационна схема, базиран на single-elimination алгоритъм. Проектът включва както конзолен интерфейс, така и бекенд двигател за обработка на мачовете.

---

## Функционалности

### 1. Вход от CSV за турнир (Дариан Ганев)
Това разширение на пакета `tournament.CLI` добавя поддръжка за зареждане на участниците в турнира от CSV файл. При стартиране конзолният интерфейс представя меню, където потребителят може да избере между два метода за въвеждане: четене на имената на отборите от файл или ръчно въвеждане.  

CSV зареждачът чете съдържанието на файла и го разделя по запетаи и нови редове, така че имената на отборите могат да бъдат на един ред, разделени със запетаи, или на няколко реда. Всяка стойност се изчиства от излишни интервали, празните стойности се игнорират, а дубликатите се премахват без значение от големината на буквите, за да се избегне регистрирането на един и същи отбор два пъти.  

Системата проверява дали файлът съществува, не е празен и съдържа поне два уникални отбора преди започване на турнира. Ако някоя проверка се провали, се показва съобщение за грешка и потребителят се връща към менюто за избор на метод за въвеждане.

---

### 2. Елиминационна схема (Йордан Цонев)
Програмата приема списък с играчи и ги организира в елиминационна схема. На всеки кръг участниците се разбъркват и се групират по двойки; ако остане нечетен брой играчи, един автоматично продължава напред („bye“).  

За всяка двойка потребителят въвежда кой печели мача. Победителите се добавят в нов списък, който представлява следващия кръг. Процесът се повтаря, докато не остане един финален победител, реализирайки стандартна single-elimination логика.

---

### 3. Турнирният двигател (backend) (Диляна Василева)
Пакетът `tournament.backend` реализира турнирна система, базирана на single-elimination алгоритъм. Той е изградена около структура на двоично дърво за турнирните скоби.  

Всеки мач се представя като `BracketNode`, който може да се свързва с два дъщерни възела, съответстващи на по-ранни мачове, чиито победители се класират напред. Началният кръг се генерира чрез разбъркване на участниците и групиране по двойки в листни възли, като се обработват нечетни брой участници чрез присвояване на BYE. Кръговете от по-високо ниво се конструират рекурсивно, като се създава пълно дърво на турнира с един корен, представляващ финалния мач.  

След като скобата е построена, двигателят симулира турнира от долу нагоре. Всеки мач извлича победителите от своите дъщерни възли, запълва състезаващите се отбори и делегира избора на победител на предоставен от потребителя `ResultProvider`. Всички мачове се съхраняват за лесен достъп, което позволява системата да показва, инспектира или записва целия цикъл на турнира. Финалният победител на турнира е победителят, съхранен в кореновия възел на дървото.
